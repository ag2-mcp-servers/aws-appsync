# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T09:44:20+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Header, Path, Query
from pydantic import conint, constr

from models import (
    AccessDeniedException,
    ApiKeyLimitExceededException,
    ApiKeyValidityOutOfBoundsException,
    ApiLimitExceededException,
    AssociateApiResponse,
    BadRequestException,
    ConcurrentModificationException,
    CreateApiCacheResponse,
    CreateApiKeyResponse,
    CreateDataSourceResponse,
    CreateDomainNameResponse,
    CreateFunctionResponse,
    CreateGraphqlApiResponse,
    CreateResolverResponse,
    CreateTypeResponse,
    DeleteApiCacheResponse,
    DeleteApiKeyResponse,
    DeleteDataSourceResponse,
    DeleteDomainNameResponse,
    DeleteFunctionResponse,
    DeleteGraphqlApiResponse,
    DeleteResolverResponse,
    DeleteTypeResponse,
    DisassociateApiResponse,
    EvaluateCodeResponse,
    EvaluateMappingTemplateResponse,
    FlushApiCacheResponse,
    Format,
    GetApiAssociationResponse,
    GetApiCacheResponse,
    GetDataSourceResponse,
    GetDomainNameResponse,
    GetFunctionResponse,
    GetGraphqlApiResponse,
    GetIntrospectionSchemaResponse,
    GetResolverResponse,
    GetSchemaCreationStatusResponse,
    GetTypeResponse,
    GraphQLSchemaException,
    InternalFailureException,
    LimitExceededException,
    ListApiKeysResponse,
    ListDataSourcesResponse,
    ListDomainNamesResponse,
    ListFunctionsResponse,
    ListGraphqlApisResponse,
    ListResolversByFunctionResponse,
    ListResolversResponse,
    ListTagsForResourceResponse,
    ListTypesResponse,
    NotFoundException,
    StartSchemaCreationResponse,
    TagKeys,
    TagResourceResponse,
    UnauthorizedException,
    UntagResourceResponse,
    UpdateApiCacheResponse,
    UpdateApiKeyResponse,
    UpdateDataSourceResponse,
    UpdateDomainNameResponse,
    UpdateFunctionResponse,
    UpdateGraphqlApiResponse,
    UpdateResolverResponse,
    UpdateTypeResponse,
    V1ApisApiIdApiCachesPostRequest,
    V1ApisApiIdApiCachesUpdatePostRequest,
    V1ApisApiIdApikeysIdPostRequest,
    V1ApisApiIdApikeysPostRequest,
    V1ApisApiIdDatasourcesNamePostRequest,
    V1ApisApiIdDatasourcesPostRequest,
    V1ApisApiIdFunctionsFunctionIdPostRequest,
    V1ApisApiIdFunctionsPostRequest,
    V1ApisApiIdPostRequest,
    V1ApisApiIdSchemacreationPostRequest,
    V1ApisApiIdTypesPostRequest,
    V1ApisApiIdTypesTypeNamePostRequest,
    V1ApisApiIdTypesTypeNameResolversFieldNamePostRequest,
    V1ApisApiIdTypesTypeNameResolversPostRequest,
    V1ApisPostRequest,
    V1DataplaneEvaluatecodePostRequest,
    V1DataplaneEvaluatetemplatePostRequest,
    V1DomainnamesDomainNameApiassociationPostRequest,
    V1DomainnamesDomainNamePostRequest,
    V1DomainnamesPostRequest,
    V1TagsResourceArnPostRequest,
)

app = MCPProxy(
    contact={
        'email': 'mike.ralphson@gmail.com',
        'name': 'Mike Ralphson',
        'url': 'https://github.com/mermade/aws2openapi',
        'x-twitter': 'PermittedSoc',
    },
    description='AppSync provides API actions for creating and interacting with data sources using GraphQL from your application.',
    license={'name': 'Apache 2.0 License', 'url': 'http://www.apache.org/licenses/'},
    termsOfService='https://aws.amazon.com/service-terms/',
    title='AWS AppSync',
    version='2017-07-25',
    servers=[
        {
            'description': 'The AWSAppSync multi-region endpoint',
            'url': 'http://appsync.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The AWSAppSync multi-region endpoint',
            'url': 'https://appsync.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The AWSAppSync endpoint for China (Beijing) and China (Ningxia)',
            'url': 'http://appsync.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
        {
            'description': 'The AWSAppSync endpoint for China (Beijing) and China (Ningxia)',
            'url': 'https://appsync.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
    ],
)


@app.get(
    '/v1/apis',
    description=""" Lists your GraphQL APIs. """,
    tags=['graphql_api_management', 'function_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_graphql_apis(
    next_token: Optional[
        constr(pattern=r'[\\S]+', min_length=1, max_length=65536)
    ] = Query(None, alias='nextToken'),
    max_results: Optional[conint(ge=0, le=25)] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apis',
    description=""" Creates a <code>GraphqlApi</code> object. """,
    tags=['resource_management', 'api_key_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_graphql_api(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ApisPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apis/{apiId}',
    description=""" Deletes a <code>GraphqlApi</code> object. """,
    tags=['api_key_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_graphql_api(
    api_id: str = Path(..., alias='apiId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apis/{apiId}',
    description=""" Retrieves a <code>GraphqlApi</code> object. """,
    tags=['api_key_management', 'function_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_graphql_api(
    api_id: str = Path(..., alias='apiId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apis/{apiId}',
    description=""" Updates a <code>GraphqlApi</code> object. """,
    tags=['function_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_graphql_api(
    api_id: str = Path(..., alias='apiId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ApisApiIdPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apis/{apiId}/ApiCaches',
    description=""" Deletes an <code>ApiCache</code> object. """,
    tags=['api_key_management', 'function_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_api_cache(
    api_id: str = Path(..., alias='apiId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apis/{apiId}/ApiCaches',
    description=""" Retrieves an <code>ApiCache</code> object. """,
    tags=['api_key_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_api_cache(
    api_id: str = Path(..., alias='apiId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apis/{apiId}/ApiCaches',
    description=""" Creates a cache for the GraphQL API. """,
    tags=['api_cache_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_api_cache(
    api_id: str = Path(..., alias='apiId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ApisApiIdApiCachesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apis/{apiId}/ApiCaches/update',
    description=""" Updates the cache for the GraphQL API. """,
    tags=['api_cache_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_api_cache(
    api_id: str = Path(..., alias='apiId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ApisApiIdApiCachesUpdatePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apis/{apiId}/FlushCache',
    description=""" Flushes an <code>ApiCache</code> object. """,
    tags=['api_key_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def flush_api_cache(
    api_id: str = Path(..., alias='apiId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apis/{apiId}/apikeys',
    description=""" <p>Lists the API keys for a given API.</p> <note> <p>API keys are deleted automatically 60 days after they expire. However, they may still be included in the response until they have actually been deleted. You can safely call <code>DeleteApiKey</code> to manually delete a key before it's automatically deleted.</p> </note> """,
    tags=['graphql_api_management', 'api_key_management', 'function_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_api_keys(
    api_id: str = Path(..., alias='apiId'),
    next_token: Optional[
        constr(pattern=r'[\\S]+', min_length=1, max_length=65536)
    ] = Query(None, alias='nextToken'),
    max_results: Optional[conint(ge=0, le=25)] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apis/{apiId}/apikeys',
    description=""" Creates a unique key that you can distribute to clients who invoke your API. """,
    tags=['api_key_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_api_key(
    api_id: str = Path(..., alias='apiId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ApisApiIdApikeysPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apis/{apiId}/apikeys/{id}',
    description=""" Deletes an API key. """,
    tags=['api_key_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_api_key(
    api_id: str = Path(..., alias='apiId'),
    id: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apis/{apiId}/apikeys/{id}',
    description=""" Updates an API key. You can update the key as long as it's not deleted. """,
    tags=['api_key_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_api_key(
    api_id: str = Path(..., alias='apiId'),
    id: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ApisApiIdApikeysIdPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apis/{apiId}/datasources',
    description=""" Lists the data sources for a given API. """,
    tags=['graphql_api_management', 'api_key_management', 'function_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_data_sources(
    api_id: str = Path(..., alias='apiId'),
    next_token: Optional[
        constr(pattern=r'[\\S]+', min_length=1, max_length=65536)
    ] = Query(None, alias='nextToken'),
    max_results: Optional[conint(ge=0, le=25)] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apis/{apiId}/datasources',
    description=""" Creates a <code>DataSource</code> object. """,
    tags=['data_source_management', 'function_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_data_source(
    api_id: str = Path(..., alias='apiId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ApisApiIdDatasourcesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apis/{apiId}/datasources/{name}',
    description=""" Deletes a <code>DataSource</code> object. """,
    tags=['graphql_api_management', 'function_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_data_source(
    api_id: str = Path(..., alias='apiId'),
    name: constr(
        pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536
    ) = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apis/{apiId}/datasources/{name}',
    description=""" Retrieves a <code>DataSource</code> object. """,
    tags=['graphql_api_management', 'function_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_data_source(
    api_id: str = Path(..., alias='apiId'),
    name: constr(
        pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536
    ) = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apis/{apiId}/datasources/{name}',
    description=""" Updates a <code>DataSource</code> object. """,
    tags=['data_source_management', 'function_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_data_source(
    api_id: str = Path(..., alias='apiId'),
    name: constr(
        pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536
    ) = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ApisApiIdDatasourcesNamePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apis/{apiId}/functions',
    description=""" List multiple functions. """,
    tags=['graphql_api_management', 'function_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_functions(
    api_id: str = Path(..., alias='apiId'),
    next_token: Optional[
        constr(pattern=r'[\\S]+', min_length=1, max_length=65536)
    ] = Query(None, alias='nextToken'),
    max_results: Optional[conint(ge=0, le=25)] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apis/{apiId}/functions',
    description=""" <p>Creates a <code>Function</code> object.</p> <p>A function is a reusable entity. You can use multiple functions to compose the resolver logic.</p> """,
    tags=['function_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_function(
    api_id: str = Path(..., alias='apiId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ApisApiIdFunctionsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apis/{apiId}/functions/{functionId}',
    description=""" Deletes a <code>Function</code>. """,
    tags=['function_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_function(
    api_id: str = Path(..., alias='apiId'),
    function_id: constr(
        pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536
    ) = Path(..., alias='functionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apis/{apiId}/functions/{functionId}',
    description=""" Get a <code>Function</code>. """,
    tags=['function_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_function(
    api_id: str = Path(..., alias='apiId'),
    function_id: constr(
        pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536
    ) = Path(..., alias='functionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apis/{apiId}/functions/{functionId}',
    description=""" Updates a <code>Function</code> object. """,
    tags=['function_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_function(
    api_id: str = Path(..., alias='apiId'),
    function_id: constr(
        pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536
    ) = Path(..., alias='functionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ApisApiIdFunctionsFunctionIdPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apis/{apiId}/functions/{functionId}/resolvers',
    description=""" List the resolvers that are associated with a specific function. """,
    tags=['function_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_resolvers_by_function(
    api_id: str = Path(..., alias='apiId'),
    function_id: str = Path(..., alias='functionId'),
    next_token: Optional[
        constr(pattern=r'[\\S]+', min_length=1, max_length=65536)
    ] = Query(None, alias='nextToken'),
    max_results: Optional[conint(ge=0, le=25)] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apis/{apiId}/schema#format',
    description=""" Retrieves the introspection schema for a GraphQL API. """,
    tags=['graphql_api_management', 'function_handling', 'api_key_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_introspection_schema(
    api_id: str = Path(..., alias='apiId'),
    format: Format = ...,
    include_directives: Optional[bool] = Query(None, alias='includeDirectives'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apis/{apiId}/schemacreation',
    description=""" Retrieves the current status of a schema creation operation. """,
    tags=['api_key_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_schema_creation_status(
    api_id: str = Path(..., alias='apiId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apis/{apiId}/schemacreation',
    description=""" <p>Adds a new schema to your GraphQL API.</p> <p>This operation is asynchronous. Use to determine when it has completed.</p> """,
    tags=['schema_handling', 'function_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def start_schema_creation(
    api_id: str = Path(..., alias='apiId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ApisApiIdSchemacreationPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apis/{apiId}/types',
    description=""" Creates a <code>Type</code> object. """,
    tags=['graphql_api_management', 'function_handling', 'api_key_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_type(
    api_id: str = Path(..., alias='apiId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ApisApiIdTypesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apis/{apiId}/types#format',
    description=""" Lists the types for a given API. """,
    tags=['graphql_api_management', 'api_key_management', 'function_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_types(
    api_id: str = Path(..., alias='apiId'),
    format: Format = ...,
    next_token: Optional[
        constr(pattern=r'[\\S]+', min_length=1, max_length=65536)
    ] = Query(None, alias='nextToken'),
    max_results: Optional[conint(ge=0, le=25)] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apis/{apiId}/types/{typeName}',
    description=""" Deletes a <code>Type</code> object. """,
    tags=['graphql_api_management', 'type_handling', 'function_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_type(
    api_id: str = Path(..., alias='apiId'),
    type_name: constr(
        pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536
    ) = Path(..., alias='typeName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apis/{apiId}/types/{typeName}',
    description=""" Updates a <code>Type</code> object. """,
    tags=['graphql_api_management', 'type_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_type(
    api_id: str = Path(..., alias='apiId'),
    type_name: constr(
        pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536
    ) = Path(..., alias='typeName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ApisApiIdTypesTypeNamePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apis/{apiId}/types/{typeName}#format',
    description=""" Retrieves a <code>Type</code> object. """,
    tags=['graphql_api_management', 'function_handling', 'type_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_type(
    api_id: str = Path(..., alias='apiId'),
    type_name: constr(
        pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536
    ) = Path(..., alias='typeName'),
    format: Format = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apis/{apiId}/types/{typeName}/resolvers',
    description=""" Lists the resolvers for a given API and type. """,
    tags=['graphql_api_management', 'type_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_resolvers(
    api_id: str = Path(..., alias='apiId'),
    type_name: str = Path(..., alias='typeName'),
    next_token: Optional[
        constr(pattern=r'[\\S]+', min_length=1, max_length=65536)
    ] = Query(None, alias='nextToken'),
    max_results: Optional[conint(ge=0, le=25)] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apis/{apiId}/types/{typeName}/resolvers',
    description=""" <p>Creates a <code>Resolver</code> object.</p> <p>A resolver converts incoming requests into a format that a data source can understand, and converts the data source's responses into GraphQL.</p> """,
    tags=['graphql_api_management', 'resolver_handling', 'type_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_resolver(
    api_id: str = Path(..., alias='apiId'),
    type_name: constr(
        pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536
    ) = Path(..., alias='typeName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ApisApiIdTypesTypeNameResolversPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apis/{apiId}/types/{typeName}/resolvers/{fieldName}',
    description=""" Deletes a <code>Resolver</code> object. """,
    tags=['graphql_api_management', 'type_handling', 'resolver_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_resolver(
    api_id: str = Path(..., alias='apiId'),
    type_name: constr(
        pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536
    ) = Path(..., alias='typeName'),
    field_name: constr(
        pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536
    ) = Path(..., alias='fieldName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apis/{apiId}/types/{typeName}/resolvers/{fieldName}',
    description=""" Retrieves a <code>Resolver</code> object. """,
    tags=['graphql_api_management', 'type_handling', 'resolver_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_resolver(
    api_id: str = Path(..., alias='apiId'),
    type_name: constr(
        pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536
    ) = Path(..., alias='typeName'),
    field_name: constr(
        pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536
    ) = Path(..., alias='fieldName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apis/{apiId}/types/{typeName}/resolvers/{fieldName}',
    description=""" Updates a <code>Resolver</code> object. """,
    tags=['graphql_api_management', 'resolver_handling', 'type_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_resolver(
    api_id: str = Path(..., alias='apiId'),
    type_name: constr(
        pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536
    ) = Path(..., alias='typeName'),
    field_name: constr(
        pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536
    ) = Path(..., alias='fieldName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1ApisApiIdTypesTypeNameResolversFieldNamePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/dataplane-evaluatecode',
    description=""" Evaluates the given code and returns the response. The code definition requirements depend on the specified runtime. For <code>APPSYNC_JS</code> runtimes, the code defines the request and response functions. The request function takes the incoming request after a GraphQL operation is parsed and converts it into a request configuration for the selected data source operation. The response function interprets responses from the data source and maps it to the shape of the GraphQL field output type.  """,
    tags=['code_evaluation_functions'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def evaluate_code(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1DataplaneEvaluatecodePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/dataplane-evaluatetemplate',
    description=""" <p>Evaluates a given template and returns the response. The mapping template can be a request or response template.</p> <p>Request templates take the incoming request after a GraphQL operation is parsed and convert it into a request configuration for the selected data source operation. Response templates interpret responses from the data source and map it to the shape of the GraphQL field output type.</p> <p>Mapping templates are written in the Apache Velocity Template Language (VTL).</p> """,
    tags=['code_evaluation_functions'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def evaluate_mapping_template(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1DataplaneEvaluatetemplatePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/domainnames',
    description=""" Lists multiple custom domain names. """,
    tags=['api_key_management', 'resource_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_domain_names(
    next_token: Optional[
        constr(pattern=r'[\\S]+', min_length=1, max_length=65536)
    ] = Query(None, alias='nextToken'),
    max_results: Optional[conint(ge=0, le=25)] = Query(None, alias='maxResults'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/domainnames',
    description=""" Creates a custom <code>DomainName</code> object. """,
    tags=['domain_configuration', 'api_domain_association'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_domain_name(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1DomainnamesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/domainnames/{domainName}',
    description=""" Deletes a custom <code>DomainName</code> object. """,
    tags=['domain_configuration', 'api_domain_association'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_domain_name(
    domain_name: constr(
        pattern=r'^(\*[\w\d-]*\.)?([\w\d-]+\.)+[\w\d-]+$', min_length=1, max_length=253
    ) = Path(..., alias='domainName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/domainnames/{domainName}',
    description=""" Retrieves a custom <code>DomainName</code> object. """,
    tags=['domain_configuration', 'api_domain_association'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_domain_name(
    domain_name: constr(
        pattern=r'^(\*[\w\d-]*\.)?([\w\d-]+\.)+[\w\d-]+$', min_length=1, max_length=253
    ) = Path(..., alias='domainName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/domainnames/{domainName}',
    description=""" Updates a custom <code>DomainName</code> object. """,
    tags=['domain_configuration', 'api_domain_association'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_domain_name(
    domain_name: constr(
        pattern=r'^(\*[\w\d-]*\.)?([\w\d-]+\.)+[\w\d-]+$', min_length=1, max_length=253
    ) = Path(..., alias='domainName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1DomainnamesDomainNamePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/domainnames/{domainName}/apiassociation',
    description=""" Removes an <code>ApiAssociation</code> object from a custom domain. """,
    tags=['domain_configuration', 'api_domain_association'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def disassociate_api(
    domain_name: constr(
        pattern=r'^(\*[\w\d-]*\.)?([\w\d-]+\.)+[\w\d-]+$', min_length=1, max_length=253
    ) = Path(..., alias='domainName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/domainnames/{domainName}/apiassociation',
    description=""" Retrieves an <code>ApiAssociation</code> object. """,
    tags=['domain_configuration', 'api_domain_association'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_api_association(
    domain_name: constr(
        pattern=r'^(\*[\w\d-]*\.)?([\w\d-]+\.)+[\w\d-]+$', min_length=1, max_length=253
    ) = Path(..., alias='domainName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/domainnames/{domainName}/apiassociation',
    description=""" Maps an endpoint to your custom domain. """,
    tags=['domain_configuration', 'api_domain_association'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def associate_api(
    domain_name: constr(
        pattern=r'^(\*[\w\d-]*\.)?([\w\d-]+\.)+[\w\d-]+$', min_length=1, max_length=253
    ) = Path(..., alias='domainName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1DomainnamesDomainNameApiassociationPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/tags/{resourceArn}',
    description=""" Lists the tags for a resource. """,
    tags=['graphql_api_management', 'resource_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_tags_for_resource(
    resource_arn: constr(
        pattern=r'^arn:aws:appsync:[A-Za-z0-9_/.-]{0,63}:\d{12}:apis/[0-9A-Za-z_-]{26}$',
        min_length=70,
        max_length=75,
    ) = Path(..., alias='resourceArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/tags/{resourceArn}',
    description=""" Tags a resource with user-supplied tags. """,
    tags=['graphql_api_management', 'resource_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def tag_resource(
    resource_arn: constr(
        pattern=r'^arn:aws:appsync:[A-Za-z0-9_/.-]{0,63}:\d{12}:apis/[0-9A-Za-z_-]{26}$',
        min_length=70,
        max_length=75,
    ) = Path(..., alias='resourceArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1TagsResourceArnPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/tags/{resourceArn}#tagKeys',
    description=""" Untags a resource. """,
    tags=['resource_management', 'graphql_api_management', 'api_domain_association'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def untag_resource(
    resource_arn: constr(
        pattern=r'^arn:aws:appsync:[A-Za-z0-9_/.-]{0,63}:\d{12}:apis/[0-9A-Za-z_-]{26}$',
        min_length=70,
        max_length=75,
    ) = Path(..., alias='resourceArn'),
    tag_keys: TagKeys = Query(..., alias='tagKeys'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
