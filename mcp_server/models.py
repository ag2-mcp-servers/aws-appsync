# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T09:44:20+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, ConfigDict, Field, RootModel, conint, constr


class AccessDeniedException(RootModel[Any]):
    root: Any


class ApiCacheStatus(Enum):
    AVAILABLE = 'AVAILABLE'
    CREATING = 'CREATING'
    DELETING = 'DELETING'
    MODIFYING = 'MODIFYING'
    FAILED = 'FAILED'


class ApiCacheType(Enum):
    T2_SMALL = 'T2_SMALL'
    T2_MEDIUM = 'T2_MEDIUM'
    R4_LARGE = 'R4_LARGE'
    R4_XLARGE = 'R4_XLARGE'
    R4_2XLARGE = 'R4_2XLARGE'
    R4_4XLARGE = 'R4_4XLARGE'
    R4_8XLARGE = 'R4_8XLARGE'
    SMALL = 'SMALL'
    MEDIUM = 'MEDIUM'
    LARGE = 'LARGE'
    XLARGE = 'XLARGE'
    LARGE_2X = 'LARGE_2X'
    LARGE_4X = 'LARGE_4X'
    LARGE_8X = 'LARGE_8X'
    LARGE_12X = 'LARGE_12X'


class ApiCachingBehavior(Enum):
    FULL_REQUEST_CACHING = 'FULL_REQUEST_CACHING'
    PER_RESOLVER_CACHING = 'PER_RESOLVER_CACHING'


class ApiKeyLimitExceededException(RootModel[Any]):
    root: Any


class ApiKeyValidityOutOfBoundsException(RootModel[Any]):
    root: Any


class ApiLimitExceededException(RootModel[Any]):
    root: Any


class AssociationStatus(Enum):
    PROCESSING = 'PROCESSING'
    FAILED = 'FAILED'
    SUCCESS = 'SUCCESS'


class AuthenticationType(Enum):
    API_KEY = 'API_KEY'
    AWS_IAM = 'AWS_IAM'
    AMAZON_COGNITO_USER_POOLS = 'AMAZON_COGNITO_USER_POOLS'
    OPENID_CONNECT = 'OPENID_CONNECT'
    AWS_LAMBDA = 'AWS_LAMBDA'


class AuthorizationType(Enum):
    AWS_IAM = 'AWS_IAM'


class BadRequestException(RootModel[Any]):
    root: Any


class Blob(RootModel[str]):
    root: str


class Boolean(RootModel[bool]):
    root: bool


class BooleanValue(RootModel[bool]):
    root: bool


class CertificateArn(
    RootModel[
        constr(
            pattern=r'^arn:[a-z-]*:(acm|iam):[a-z0-9-]*:\d{12}:(certificate|server-certificate)/[0-9A-Za-z_/-]*$',
            min_length=20,
            max_length=2048,
        )
    ]
):
    root: constr(
        pattern=r'^arn:[a-z-]*:(acm|iam):[a-z0-9-]*:\d{12}:(certificate|server-certificate)/[0-9A-Za-z_/-]*$',
        min_length=20,
        max_length=2048,
    )


class Code(RootModel[constr(min_length=1, max_length=32768)]):
    root: constr(min_length=1, max_length=32768)


class CodeErrorColumn(RootModel[int]):
    root: int


class CodeErrorLine(RootModel[int]):
    root: int


class CodeErrorSpan(RootModel[int]):
    root: int


class ConcurrentModificationException(RootModel[Any]):
    root: Any


class ConflictDetectionType(Enum):
    VERSION = 'VERSION'
    NONE = 'NONE'


class ConflictHandlerType(Enum):
    OPTIMISTIC_CONCURRENCY = 'OPTIMISTIC_CONCURRENCY'
    LAMBDA = 'LAMBDA'
    AUTOMERGE = 'AUTOMERGE'
    NONE = 'NONE'


class Context(RootModel[constr(pattern=r'^[\s\S]*$', min_length=2, max_length=28000)]):
    root: constr(pattern=r'^[\s\S]*$', min_length=2, max_length=28000)


class DataSourceType(Enum):
    AWS_LAMBDA = 'AWS_LAMBDA'
    AMAZON_DYNAMODB = 'AMAZON_DYNAMODB'
    AMAZON_ELASTICSEARCH = 'AMAZON_ELASTICSEARCH'
    NONE = 'NONE'
    HTTP = 'HTTP'
    RELATIONAL_DATABASE = 'RELATIONAL_DATABASE'
    AMAZON_OPENSEARCH_SERVICE = 'AMAZON_OPENSEARCH_SERVICE'
    AMAZON_EVENTBRIDGE = 'AMAZON_EVENTBRIDGE'


class DefaultAction(Enum):
    ALLOW = 'ALLOW'
    DENY = 'DENY'


class DeleteApiCacheRequest(BaseModel):
    pass


class DeleteApiCacheResponse(BaseModel):
    pass


class DeleteApiKeyRequest(BaseModel):
    pass


class DeleteApiKeyResponse(BaseModel):
    pass


class DeleteDataSourceRequest(BaseModel):
    pass


class DeleteDataSourceResponse(BaseModel):
    pass


class DeleteDomainNameRequest(BaseModel):
    pass


class DeleteDomainNameResponse(BaseModel):
    pass


class DeleteFunctionRequest(BaseModel):
    pass


class DeleteFunctionResponse(BaseModel):
    pass


class DeleteGraphqlApiRequest(BaseModel):
    pass


class DeleteGraphqlApiResponse(BaseModel):
    pass


class DeleteResolverRequest(BaseModel):
    pass


class DeleteResolverResponse(BaseModel):
    pass


class DeleteTypeRequest(BaseModel):
    pass


class DeleteTypeResponse(BaseModel):
    pass


class Description(RootModel[constr(pattern=r'^.*$', min_length=0, max_length=255)]):
    root: constr(pattern=r'^.*$', min_length=0, max_length=255)


class DisassociateApiRequest(BaseModel):
    pass


class DisassociateApiResponse(BaseModel):
    pass


class DomainName(
    RootModel[
        constr(
            pattern=r'^(\*[\w\d-]*\.)?([\w\d-]+\.)+[\w\d-]+$',
            min_length=1,
            max_length=253,
        )
    ]
):
    root: constr(
        pattern=r'^(\*[\w\d-]*\.)?([\w\d-]+\.)+[\w\d-]+$', min_length=1, max_length=253
    )


class ErrorMessage(RootModel[str]):
    root: str


class EvaluationResult(
    RootModel[constr(pattern=r'^[\s\S]*$', min_length=0, max_length=65536)]
):
    root: constr(pattern=r'^[\s\S]*$', min_length=0, max_length=65536)


class FieldLogLevel(Enum):
    NONE = 'NONE'
    ERROR = 'ERROR'
    ALL = 'ALL'


class FlushApiCacheRequest(BaseModel):
    pass


class FlushApiCacheResponse(BaseModel):
    pass


class GetApiAssociationRequest(BaseModel):
    pass


class GetApiCacheRequest(BaseModel):
    pass


class GetDataSourceRequest(BaseModel):
    pass


class GetDomainNameRequest(BaseModel):
    pass


class GetFunctionRequest(BaseModel):
    pass


class GetGraphqlApiRequest(BaseModel):
    pass


class GetIntrospectionSchemaRequest(BaseModel):
    pass


class GetIntrospectionSchemaResponse(BaseModel):
    schema_: Optional[Blob] = Field(None, alias='schema')


class GetResolverRequest(BaseModel):
    pass


class GetSchemaCreationStatusRequest(BaseModel):
    pass


class GetTypeRequest(BaseModel):
    pass


class GraphQLSchemaException(RootModel[Any]):
    root: Any


class InternalFailureException(RootModel[Any]):
    root: Any


class LimitExceededException(RootModel[Any]):
    root: Any


class ListApiKeysRequest(BaseModel):
    pass


class ListDataSourcesRequest(BaseModel):
    pass


class ListDomainNamesRequest(BaseModel):
    pass


class ListFunctionsRequest(BaseModel):
    pass


class ListGraphqlApisRequest(BaseModel):
    pass


class ListResolversByFunctionRequest(BaseModel):
    pass


class ListResolversRequest(BaseModel):
    pass


class ListTagsForResourceRequest(BaseModel):
    pass


class ListTypesRequest(BaseModel):
    pass


class Long(RootModel[int]):
    root: int


class MappingTemplate(
    RootModel[constr(pattern=r'^.*$', min_length=1, max_length=65536)]
):
    root: constr(pattern=r'^.*$', min_length=1, max_length=65536)


class MaxBatchSize(RootModel[conint(ge=0, le=2000)]):
    root: conint(ge=0, le=2000)


class MaxResults(RootModel[conint(ge=0, le=25)]):
    root: conint(ge=0, le=25)


class NotFoundException(RootModel[Any]):
    root: Any


class OutputType(Enum):
    SDL = 'SDL'
    JSON = 'JSON'


class PaginationToken(
    RootModel[constr(pattern=r'[\\S]+', min_length=1, max_length=65536)]
):
    root: constr(pattern=r'[\\S]+', min_length=1, max_length=65536)


class RelationalDatabaseSourceType(Enum):
    RDS_HTTP_ENDPOINT = 'RDS_HTTP_ENDPOINT'


class ResolverKind(Enum):
    UNIT = 'UNIT'
    PIPELINE = 'PIPELINE'


class ResourceArn(
    RootModel[
        constr(
            pattern=r'^arn:aws:appsync:[A-Za-z0-9_/.-]{0,63}:\d{12}:apis/[0-9A-Za-z_-]{26}$',
            min_length=70,
            max_length=75,
        )
    ]
):
    root: constr(
        pattern=r'^arn:aws:appsync:[A-Za-z0-9_/.-]{0,63}:\d{12}:apis/[0-9A-Za-z_-]{26}$',
        min_length=70,
        max_length=75,
    )


class ResourceName(
    RootModel[constr(pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536)]
):
    root: constr(pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536)


class RuntimeName(Enum):
    APPSYNC_JS = 'APPSYNC_JS'


class SchemaStatus(Enum):
    PROCESSING = 'PROCESSING'
    ACTIVE = 'ACTIVE'
    DELETING = 'DELETING'
    FAILED = 'FAILED'
    SUCCESS = 'SUCCESS'
    NOT_APPLICABLE = 'NOT_APPLICABLE'


class StartSchemaCreationRequest(BaseModel):
    definition: Blob


class StartSchemaCreationResponse(BaseModel):
    status: Optional[SchemaStatus] = None


class String(RootModel[str]):
    root: str


class TTL(RootModel[conint(ge=0, le=3600)]):
    root: conint(ge=0, le=3600)


class TagKey(
    RootModel[
        constr(pattern=r'^(?!aws:)[ a-zA-Z+-=._:/]+$', min_length=1, max_length=128)
    ]
):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: constr(
        pattern=r'^(?!aws:)[ a-zA-Z+-=._:/]+$', min_length=1, max_length=128
    ) = Field(..., description='The key for the tag.')


class TagKeyList(RootModel[List[TagKey]]):
    root: List[TagKey] = Field(..., max_length=50, min_length=1)


class TagResourceResponse(BaseModel):
    pass


class TagValue(RootModel[constr(pattern=r'^[\s\w+-=\.:/@]*$', max_length=256)]):
    root: constr(pattern=r'^[\s\w+-=\.:/@]*$', max_length=256) = Field(
        ..., description='The value for the tag.'
    )


class Template(RootModel[constr(pattern=r'^[\s\S]*$', min_length=2, max_length=65536)]):
    root: constr(pattern=r'^[\s\S]*$', min_length=2, max_length=65536)


class TypeDefinitionFormat(Enum):
    SDL = 'SDL'
    JSON = 'JSON'


class UnauthorizedException(RootModel[Any]):
    root: Any


class UntagResourceRequest(BaseModel):
    pass


class UntagResourceResponse(BaseModel):
    pass


class UpdateApiCacheRequest(BaseModel):
    apiCachingBehavior: ApiCachingBehavior
    ttl: Long
    type: ApiCacheType


class UpdateApiKeyRequest(BaseModel):
    description: Optional[String] = None
    expires: Optional[Long] = None


class UpdateDomainNameRequest(BaseModel):
    description: Optional[Description] = None


class UpdateTypeRequest(BaseModel):
    definition: Optional[String] = None
    format: TypeDefinitionFormat


class UserPoolConfig(BaseModel):
    appIdClientRegex: Optional[String] = None
    awsRegion: String
    defaultAction: DefaultAction
    userPoolId: String


class LambdaAuthorizerConfig1(BaseModel):
    authorizerResultTtlInSeconds: Optional[TTL] = None
    authorizerUri: Optional[String] = None
    identityValidationExpression: Optional[String] = None


class LogConfig1(BaseModel):
    cloudWatchLogsRoleArn: Optional[String] = None
    excludeVerboseContent: Optional[Boolean] = None
    fieldLogLevel: Optional[FieldLogLevel] = None


class OpenIDConnectConfig1(BaseModel):
    authTTL: Optional[Long] = None
    clientId: Optional[String] = None
    iatTTL: Optional[Long] = None
    issuer: Optional[String] = None


class UserPoolConfig1(BaseModel):
    appIdClientRegex: Optional[String] = None
    awsRegion: Optional[String] = None
    defaultAction: Optional[DefaultAction] = None
    userPoolId: Optional[String] = None


class Type1(Enum):
    T2_SMALL = 'T2_SMALL'
    T2_MEDIUM = 'T2_MEDIUM'
    R4_LARGE = 'R4_LARGE'
    R4_XLARGE = 'R4_XLARGE'
    R4_2XLARGE = 'R4_2XLARGE'
    R4_4XLARGE = 'R4_4XLARGE'
    R4_8XLARGE = 'R4_8XLARGE'
    SMALL = 'SMALL'
    MEDIUM = 'MEDIUM'
    LARGE = 'LARGE'
    XLARGE = 'XLARGE'
    LARGE_2X = 'LARGE_2X'
    LARGE_4X = 'LARGE_4X'
    LARGE_8X = 'LARGE_8X'
    LARGE_12X = 'LARGE_12X'


class V1ApisApiIdApiCachesPostRequest(BaseModel):
    apiCachingBehavior: ApiCachingBehavior = Field(
        ...,
        description='<p>Caching behavior.</p> <ul> <li> <p> <b>FULL_REQUEST_CACHING</b>: All requests are fully cached.</p> </li> <li> <p> <b>PER_RESOLVER_CACHING</b>: Individual resolvers that you specify are cached.</p> </li> </ul>',
    )
    atRestEncryptionEnabled: Optional[bool] = Field(
        None,
        description='At-rest encryption flag for cache. You cannot update this setting after creation.',
    )
    transitEncryptionEnabled: Optional[bool] = Field(
        None,
        description='Transit encryption flag when connecting to cache. You cannot update this setting after creation.',
    )
    ttl: int = Field(
        ...,
        description='<p>TTL in seconds for cache entries.</p> <p>Valid values are 1–3,600 seconds.</p>',
    )
    type: Type1 = Field(
        ...,
        description='<p>The cache instance type. Valid values are </p> <ul> <li> <p> <code>SMALL</code> </p> </li> <li> <p> <code>MEDIUM</code> </p> </li> <li> <p> <code>LARGE</code> </p> </li> <li> <p> <code>XLARGE</code> </p> </li> <li> <p> <code>LARGE_2X</code> </p> </li> <li> <p> <code>LARGE_4X</code> </p> </li> <li> <p> <code>LARGE_8X</code> (not available in all regions)</p> </li> <li> <p> <code>LARGE_12X</code> </p> </li> </ul> <p>Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used.</p> <p>The following legacy instance types are available, but their use is discouraged:</p> <ul> <li> <p> <b>T2_SMALL</b>: A t2.small instance type.</p> </li> <li> <p> <b>T2_MEDIUM</b>: A t2.medium instance type.</p> </li> <li> <p> <b>R4_LARGE</b>: A r4.large instance type.</p> </li> <li> <p> <b>R4_XLARGE</b>: A r4.xlarge instance type.</p> </li> <li> <p> <b>R4_2XLARGE</b>: A r4.2xlarge instance type.</p> </li> <li> <p> <b>R4_4XLARGE</b>: A r4.4xlarge instance type.</p> </li> <li> <p> <b>R4_8XLARGE</b>: A r4.8xlarge instance type.</p> </li> </ul>',
    )


class V1ApisApiIdApiCachesUpdatePostRequest(BaseModel):
    apiCachingBehavior: ApiCachingBehavior = Field(
        ...,
        description='<p>Caching behavior.</p> <ul> <li> <p> <b>FULL_REQUEST_CACHING</b>: All requests are fully cached.</p> </li> <li> <p> <b>PER_RESOLVER_CACHING</b>: Individual resolvers that you specify are cached.</p> </li> </ul>',
    )
    ttl: int = Field(
        ...,
        description='<p>TTL in seconds for cache entries.</p> <p>Valid values are 1–3,600 seconds.</p>',
    )
    type: Type1 = Field(
        ...,
        description='<p>The cache instance type. Valid values are </p> <ul> <li> <p> <code>SMALL</code> </p> </li> <li> <p> <code>MEDIUM</code> </p> </li> <li> <p> <code>LARGE</code> </p> </li> <li> <p> <code>XLARGE</code> </p> </li> <li> <p> <code>LARGE_2X</code> </p> </li> <li> <p> <code>LARGE_4X</code> </p> </li> <li> <p> <code>LARGE_8X</code> (not available in all regions)</p> </li> <li> <p> <code>LARGE_12X</code> </p> </li> </ul> <p>Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used.</p> <p>The following legacy instance types are available, but their use is discouraged:</p> <ul> <li> <p> <b>T2_SMALL</b>: A t2.small instance type.</p> </li> <li> <p> <b>T2_MEDIUM</b>: A t2.medium instance type.</p> </li> <li> <p> <b>R4_LARGE</b>: A r4.large instance type.</p> </li> <li> <p> <b>R4_XLARGE</b>: A r4.xlarge instance type.</p> </li> <li> <p> <b>R4_2XLARGE</b>: A r4.2xlarge instance type.</p> </li> <li> <p> <b>R4_4XLARGE</b>: A r4.4xlarge instance type.</p> </li> <li> <p> <b>R4_8XLARGE</b>: A r4.8xlarge instance type.</p> </li> </ul>',
    )


class V1ApisApiIdApikeysPostRequest(BaseModel):
    description: Optional[str] = Field(
        None, description='A description of the purpose of the API key.'
    )
    expires: Optional[int] = Field(
        None,
        description='From the creation time, the time after which the API key expires. The date is represented as seconds since the epoch, rounded down to the nearest hour. The default value for this parameter is 7 days from creation time. For more information, see .',
    )


class V1ApisApiIdApikeysIdPostRequest(BaseModel):
    description: Optional[str] = Field(
        None, description='A description of the purpose of the API key.'
    )
    expires: Optional[int] = Field(
        None,
        description='From the update time, the time after which the API key expires. The date is represented as seconds since the epoch. For more information, see .',
    )


class ElasticsearchConfig(BaseModel):
    awsRegion: Optional[String] = None
    endpoint: Optional[String] = None


class EventBridgeConfig(BaseModel):
    eventBusArn: Optional[String] = None


class LambdaConfig(BaseModel):
    lambdaFunctionArn: Optional[String] = None


class OpenSearchServiceConfig(BaseModel):
    awsRegion: Optional[String] = None
    endpoint: Optional[String] = None


class Type3(Enum):
    AWS_LAMBDA = 'AWS_LAMBDA'
    AMAZON_DYNAMODB = 'AMAZON_DYNAMODB'
    AMAZON_ELASTICSEARCH = 'AMAZON_ELASTICSEARCH'
    NONE = 'NONE'
    HTTP = 'HTTP'
    RELATIONAL_DATABASE = 'RELATIONAL_DATABASE'
    AMAZON_OPENSEARCH_SERVICE = 'AMAZON_OPENSEARCH_SERVICE'
    AMAZON_EVENTBRIDGE = 'AMAZON_EVENTBRIDGE'


class Runtime(BaseModel):
    name: Optional[RuntimeName] = None
    runtimeVersion: Optional[String] = None


class Format(Enum):
    SDL = 'SDL'
    JSON = 'JSON'


class V1ApisApiIdSchemacreationPostRequest(BaseModel):
    definition: str = Field(
        ..., description='The schema definition, in GraphQL schema language format.'
    )


class V1ApisApiIdTypesPostRequest(BaseModel):
    definition: str = Field(
        ...,
        description='<p>The type definition, in GraphQL Schema Definition Language (SDL) format.</p> <p>For more information, see the <a href="http://graphql.org/learn/schema/">GraphQL SDL documentation</a>.</p>',
    )
    format: Format = Field(..., description='The type format: SDL or JSON.')


class V1ApisApiIdTypesTypeNamePostRequest(BaseModel):
    definition: Optional[str] = Field(None, description='The new definition.')
    format: Format = Field(..., description='The new type format: SDL or JSON.')


class Kind(Enum):
    UNIT = 'UNIT'
    PIPELINE = 'PIPELINE'


class V1DataplaneEvaluatecodePostRequest(BaseModel):
    code: constr(min_length=1, max_length=32768) = Field(
        ...,
        description='The code definition to be evaluated. Note that <code>code</code> and <code>runtime</code> are both required for this action. The <code>runtime</code> value must be <code>APPSYNC_JS</code>.',
    )
    context: constr(pattern=r'^[\s\S]*$', min_length=2, max_length=28000) = Field(
        ...,
        description='The map that holds all of the contextual information for your resolver invocation. A <code>context</code> is required for this action.',
    )
    function: Optional[str] = Field(
        None,
        description='The function within the code to be evaluated. If provided, the valid values are <code>request</code> and <code>response</code>.',
    )
    runtime: Runtime = Field(
        ...,
        description='Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.',
    )


class V1DataplaneEvaluatetemplatePostRequest(BaseModel):
    context: constr(pattern=r'^[\s\S]*$', min_length=2, max_length=28000) = Field(
        ...,
        description='The map that holds all of the contextual information for your resolver invocation. A <code>context</code> is required for this action.',
    )
    template: constr(pattern=r'^[\s\S]*$', min_length=2, max_length=65536) = Field(
        ...,
        description='The mapping template; this can be a request or response template. A <code>template</code> is required for this action.',
    )


class V1DomainnamesPostRequest(BaseModel):
    certificateArn: constr(
        pattern=r'^arn:[a-z-]*:(acm|iam):[a-z0-9-]*:\d{12}:(certificate|server-certificate)/[0-9A-Za-z_/-]*$',
        min_length=20,
        max_length=2048,
    ) = Field(
        ...,
        description='The Amazon Resource Name (ARN) of the certificate. This can be an Certificate Manager (ACM) certificate or an Identity and Access Management (IAM) server certificate.',
    )
    description: Optional[constr(pattern=r'^.*$', min_length=0, max_length=255)] = (
        Field(None, description='A description of the <code>DomainName</code>.')
    )
    domainName: constr(
        pattern=r'^(\*[\w\d-]*\.)?([\w\d-]+\.)+[\w\d-]+$', min_length=1, max_length=253
    ) = Field(..., description='The domain name.')


class V1DomainnamesDomainNamePostRequest(BaseModel):
    description: Optional[constr(pattern=r'^.*$', min_length=0, max_length=255)] = (
        Field(None, description='A description of the <code>DomainName</code>.')
    )


class V1DomainnamesDomainNameApiassociationPostRequest(BaseModel):
    apiId: str = Field(..., description='The API ID.')


class V1TagsResourceArnPostRequest(BaseModel):
    tags: Dict[str, TagValue] = Field(
        ...,
        description='A map with keys of <code>TagKey</code> objects and values of <code>TagValue</code> objects.',
    )


class TagKeys(RootModel[List[TagKey]]):
    root: List[TagKey] = Field(..., max_length=50, min_length=1)


class ApiAssociation(BaseModel):
    apiId: Optional[String] = None
    associationStatus: Optional[AssociationStatus] = None
    deploymentDetail: Optional[String] = None
    domainName: Optional[DomainName] = None


class ApiCache(BaseModel):
    apiCachingBehavior: Optional[ApiCachingBehavior] = None
    atRestEncryptionEnabled: Optional[Boolean] = None
    status: Optional[ApiCacheStatus] = None
    transitEncryptionEnabled: Optional[Boolean] = None
    ttl: Optional[Long] = None
    type: Optional[ApiCacheType] = None


class ApiKey(BaseModel):
    deletes: Optional[Long] = None
    description: Optional[String] = None
    expires: Optional[Long] = None
    id: Optional[String] = None


class ApiKeys(RootModel[List[ApiKey]]):
    root: List[ApiKey]


class AppSyncRuntime(BaseModel):
    name: RuntimeName
    runtimeVersion: String


class AssociateApiRequest(BaseModel):
    apiId: String


class AssociateApiResponse(BaseModel):
    apiAssociation: Optional[ApiAssociation] = None


class AwsIamConfig(BaseModel):
    signingRegion: Optional[String] = None
    signingServiceName: Optional[String] = None


class CachingKeys(RootModel[List[String]]):
    root: List[String]


class CodeErrorLocation(BaseModel):
    column: Optional[CodeErrorColumn] = None
    line: Optional[CodeErrorLine] = None
    span: Optional[CodeErrorSpan] = None


class CognitoUserPoolConfig(BaseModel):
    appIdClientRegex: Optional[String] = None
    awsRegion: String
    userPoolId: String


class CreateApiCacheRequest(BaseModel):
    apiCachingBehavior: ApiCachingBehavior
    atRestEncryptionEnabled: Optional[Boolean] = None
    transitEncryptionEnabled: Optional[Boolean] = None
    ttl: Long
    type: ApiCacheType


class CreateApiCacheResponse(BaseModel):
    apiCache: Optional[ApiCache] = None


class CreateApiKeyRequest(BaseModel):
    description: Optional[String] = None
    expires: Optional[Long] = None


class CreateApiKeyResponse(BaseModel):
    apiKey: Optional[ApiKey] = None


class CreateDomainNameRequest(BaseModel):
    certificateArn: CertificateArn
    description: Optional[Description] = None
    domainName: DomainName


class CreateTypeRequest(BaseModel):
    definition: String
    format: TypeDefinitionFormat


class DeltaSyncConfig(BaseModel):
    baseTableTTL: Optional[Long] = None
    deltaSyncTableName: Optional[String] = None
    deltaSyncTableTTL: Optional[Long] = None


class DomainNameConfig(BaseModel):
    appsyncDomainName: Optional[String] = None
    certificateArn: Optional[CertificateArn] = None
    description: Optional[Description] = None
    domainName: Optional[DomainName] = None
    hostedZoneId: Optional[String] = None


class DomainNameConfigs(RootModel[List[DomainNameConfig]]):
    root: List[DomainNameConfig]


class DynamodbDataSourceConfig(BaseModel):
    awsRegion: String
    deltaSyncConfig: Optional[DeltaSyncConfig] = None
    tableName: String
    useCallerCredentials: Optional[Boolean] = None
    versioned: Optional[Boolean] = None


class ElasticsearchDataSourceConfig(BaseModel):
    awsRegion: String
    endpoint: String


class ErrorDetail(BaseModel):
    message: Optional[ErrorMessage] = None


class EvaluateCodeRequest(BaseModel):
    code: Code
    context: Context
    function: Optional[String] = None
    runtime: AppSyncRuntime


class EvaluateMappingTemplateRequest(BaseModel):
    context: Context
    template: Template


class EventBridgeDataSourceConfig(BaseModel):
    eventBusArn: String


class FunctionsIds(RootModel[List[String]]):
    root: List[String]


class GetApiAssociationResponse(BaseModel):
    apiAssociation: Optional[ApiAssociation] = None


class GetApiCacheResponse(BaseModel):
    apiCache: Optional[ApiCache] = None


class GetDomainNameResponse(BaseModel):
    domainNameConfig: Optional[DomainNameConfig] = None


class GetSchemaCreationStatusResponse(BaseModel):
    details: Optional[String] = None
    status: Optional[SchemaStatus] = None


class LambdaAuthorizerConfig(BaseModel):
    authorizerResultTtlInSeconds: Optional[TTL] = None
    authorizerUri: String
    identityValidationExpression: Optional[String] = None


class LambdaConflictHandlerConfig(BaseModel):
    lambdaConflictHandlerArn: Optional[String] = None


class LambdaDataSourceConfig(BaseModel):
    lambdaFunctionArn: String


class ListApiKeysResponse(BaseModel):
    apiKeys: Optional[ApiKeys] = None
    nextToken: Optional[PaginationToken] = None


class ListDomainNamesResponse(BaseModel):
    domainNameConfigs: Optional[DomainNameConfigs] = None
    nextToken: Optional[PaginationToken] = None


class LogConfig(BaseModel):
    cloudWatchLogsRoleArn: String
    excludeVerboseContent: Optional[Boolean] = None
    fieldLogLevel: FieldLogLevel


class Logs(RootModel[List[String]]):
    root: List[String]


class MapOfStringToString(RootModel[Optional[Dict[str, String]]]):
    root: Optional[Dict[str, String]] = None


class OpenIDConnectConfig(BaseModel):
    authTTL: Optional[Long] = None
    clientId: Optional[String] = None
    iatTTL: Optional[Long] = None
    issuer: String


class OpenSearchServiceDataSourceConfig(BaseModel):
    awsRegion: String
    endpoint: String


class PipelineConfig(BaseModel):
    functions: Optional[FunctionsIds] = None


class RdsHttpEndpointConfig(BaseModel):
    awsRegion: Optional[String] = None
    awsSecretStoreArn: Optional[String] = None
    databaseName: Optional[String] = None
    dbClusterIdentifier: Optional[String] = None
    schema_: Optional[String] = Field(None, alias='schema')


class RelationalDatabaseDataSourceConfig(BaseModel):
    rdsHttpEndpointConfig: Optional[RdsHttpEndpointConfig] = None
    relationalDatabaseSourceType: Optional[RelationalDatabaseSourceType] = None


class SyncConfig(BaseModel):
    conflictDetection: Optional[ConflictDetectionType] = None
    conflictHandler: Optional[ConflictHandlerType] = None
    lambdaConflictHandlerConfig: Optional[LambdaConflictHandlerConfig] = None


class TagMap(RootModel[Optional[Dict[str, TagValue]]]):
    root: Optional[Dict[str, TagValue]] = None


class TagResourceRequest(BaseModel):
    tags: TagMap


class Type(BaseModel):
    arn: Optional[String] = None
    definition: Optional[String] = None
    description: Optional[String] = None
    format: Optional[TypeDefinitionFormat] = None
    name: Optional[ResourceName] = None


class TypeList(RootModel[List[Type]]):
    root: List[Type]


class UpdateApiCacheResponse(BaseModel):
    apiCache: Optional[ApiCache] = None


class UpdateApiKeyResponse(BaseModel):
    apiKey: Optional[ApiKey] = None


class UpdateDomainNameResponse(BaseModel):
    domainNameConfig: Optional[DomainNameConfig] = None


class UpdateFunctionRequest(BaseModel):
    code: Optional[Code] = None
    dataSourceName: ResourceName
    description: Optional[String] = None
    functionVersion: Optional[String] = None
    maxBatchSize: Optional[MaxBatchSize] = None
    name: ResourceName
    requestMappingTemplate: Optional[MappingTemplate] = None
    responseMappingTemplate: Optional[MappingTemplate] = None
    runtime: Optional[AppSyncRuntime] = None
    syncConfig: Optional[SyncConfig] = None


class UpdateTypeResponse(BaseModel):
    type: Optional[Type] = None


class DynamodbConfig(BaseModel):
    awsRegion: Optional[String] = None
    deltaSyncConfig: Optional[DeltaSyncConfig] = None
    tableName: Optional[String] = None
    useCallerCredentials: Optional[Boolean] = None
    versioned: Optional[Boolean] = None


class RelationalDatabaseConfig(BaseModel):
    rdsHttpEndpointConfig: Optional[RdsHttpEndpointConfig] = None
    relationalDatabaseSourceType: Optional[RelationalDatabaseSourceType] = None


class V1ApisApiIdFunctionsPostRequest(BaseModel):
    code: Optional[constr(min_length=1, max_length=32768)] = Field(
        None,
        description='The <code>function</code> code that contains the request and response functions. When code is used, the <code>runtime</code> is required. The <code>runtime</code> value must be <code>APPSYNC_JS</code>.',
    )
    dataSourceName: constr(
        pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536
    ) = Field(
        ..., description='The <code>Function</code> <code>DataSource</code> name.'
    )
    description: Optional[str] = Field(
        None, description='The <code>Function</code> description.'
    )
    functionVersion: Optional[str] = Field(
        None,
        description='The <code>version</code> of the request mapping template. Currently, the supported value is 2018-05-29. Note that when using VTL and mapping templates, the <code>functionVersion</code> is required.',
    )
    maxBatchSize: Optional[conint(ge=0, le=2000)] = Field(
        None, description='The maximum batching size for a resolver.'
    )
    name: constr(pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536) = (
        Field(
            ...,
            description='The <code>Function</code> name. The function name does not have to be unique.',
        )
    )
    requestMappingTemplate: Optional[
        constr(pattern=r'^.*$', min_length=1, max_length=65536)
    ] = Field(
        None,
        description='The <code>Function</code> request mapping template. Functions support only the 2018-05-29 version of the request mapping template.',
    )
    responseMappingTemplate: Optional[
        constr(pattern=r'^.*$', min_length=1, max_length=65536)
    ] = Field(None, description='The <code>Function</code> response mapping template.')
    runtime: Optional[Runtime] = Field(
        None,
        description='Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.',
    )
    syncConfig: Optional[SyncConfig] = Field(
        None,
        description='<p>Describes a Sync configuration for a resolver.</p> <p>Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.</p>',
    )


class V1ApisApiIdFunctionsFunctionIdPostRequest(BaseModel):
    code: Optional[constr(min_length=1, max_length=32768)] = Field(
        None,
        description='The <code>function</code> code that contains the request and response functions. When code is used, the <code>runtime</code> is required. The <code>runtime</code> value must be <code>APPSYNC_JS</code>.',
    )
    dataSourceName: constr(
        pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536
    ) = Field(
        ..., description='The <code>Function</code> <code>DataSource</code> name.'
    )
    description: Optional[str] = Field(
        None, description='The <code>Function</code> description.'
    )
    functionVersion: Optional[str] = Field(
        None,
        description='The <code>version</code> of the request mapping template. Currently, the supported value is 2018-05-29. Note that when using VTL and mapping templates, the <code>functionVersion</code> is required.',
    )
    maxBatchSize: Optional[conint(ge=0, le=2000)] = Field(
        None, description='The maximum batching size for a resolver.'
    )
    name: constr(pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536) = (
        Field(..., description='The <code>Function</code> name.')
    )
    requestMappingTemplate: Optional[
        constr(pattern=r'^.*$', min_length=1, max_length=65536)
    ] = Field(
        None,
        description='The <code>Function</code> request mapping template. Functions support only the 2018-05-29 version of the request mapping template.',
    )
    responseMappingTemplate: Optional[
        constr(pattern=r'^.*$', min_length=1, max_length=65536)
    ] = Field(None, description='The <code>Function</code> request mapping template.')
    runtime: Optional[Runtime] = Field(
        None,
        description='Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.',
    )
    syncConfig: Optional[SyncConfig] = Field(
        None,
        description='<p>Describes a Sync configuration for a resolver.</p> <p>Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.</p>',
    )


class CachingConfig1(BaseModel):
    cachingKeys: Optional[CachingKeys] = None
    ttl: Optional[Long] = None


class V1ApisApiIdTypesTypeNameResolversPostRequest(BaseModel):
    cachingConfig: Optional[CachingConfig1] = Field(
        None,
        description='The caching configuration for a resolver that has caching activated.',
    )
    code: Optional[constr(min_length=1, max_length=32768)] = Field(
        None,
        description='The <code>resolver</code> code that contains the request and response functions. When code is used, the <code>runtime</code> is required. The <code>runtime</code> value must be <code>APPSYNC_JS</code>.',
    )
    dataSourceName: Optional[
        constr(pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536)
    ] = Field(
        None,
        description='The name of the data source for which the resolver is being created.',
    )
    fieldName: constr(
        pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536
    ) = Field(..., description='The name of the field to attach the resolver to.')
    kind: Optional[Kind] = Field(
        None,
        description='<p>The resolver type.</p> <ul> <li> <p> <b>UNIT</b>: A UNIT resolver type. A UNIT resolver is the default resolver type. You can use a UNIT resolver to run a GraphQL query against a single data source.</p> </li> <li> <p> <b>PIPELINE</b>: A PIPELINE resolver type. You can use a PIPELINE resolver to invoke a series of <code>Function</code> objects in a serial manner. You can use a pipeline resolver to run a GraphQL query against multiple data sources.</p> </li> </ul>',
    )
    maxBatchSize: Optional[conint(ge=0, le=2000)] = Field(
        None, description='The maximum batching size for a resolver.'
    )
    pipelineConfig: Optional[PipelineConfig] = Field(
        None,
        description='The pipeline configuration for a resolver of kind <code>PIPELINE</code>.',
    )
    requestMappingTemplate: Optional[
        constr(pattern=r'^.*$', min_length=1, max_length=65536)
    ] = Field(
        None,
        description='<p>The mapping template to use for requests.</p> <p>A resolver uses a request mapping template to convert a GraphQL expression into a format that a data source can understand. Mapping templates are written in Apache Velocity Template Language (VTL).</p> <p>VTL request mapping templates are optional when using an Lambda data source. For all other data sources, VTL request and response mapping templates are required.</p>',
    )
    responseMappingTemplate: Optional[
        constr(pattern=r'^.*$', min_length=1, max_length=65536)
    ] = Field(
        None,
        description='The mapping template to use for responses from the data source.',
    )
    runtime: Optional[Runtime] = Field(
        None,
        description='Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.',
    )
    syncConfig: Optional[SyncConfig] = Field(
        None,
        description='<p>Describes a Sync configuration for a resolver.</p> <p>Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.</p>',
    )


class V1ApisApiIdTypesTypeNameResolversFieldNamePostRequest(BaseModel):
    cachingConfig: Optional[CachingConfig1] = Field(
        None,
        description='The caching configuration for a resolver that has caching activated.',
    )
    code: Optional[constr(min_length=1, max_length=32768)] = Field(
        None,
        description='The <code>resolver</code> code that contains the request and response functions. When code is used, the <code>runtime</code> is required. The <code>runtime</code> value must be <code>APPSYNC_JS</code>.',
    )
    dataSourceName: Optional[
        constr(pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536)
    ] = Field(None, description='The new data source name.')
    kind: Optional[Kind] = Field(
        None,
        description='<p>The resolver type.</p> <ul> <li> <p> <b>UNIT</b>: A UNIT resolver type. A UNIT resolver is the default resolver type. You can use a UNIT resolver to run a GraphQL query against a single data source.</p> </li> <li> <p> <b>PIPELINE</b>: A PIPELINE resolver type. You can use a PIPELINE resolver to invoke a series of <code>Function</code> objects in a serial manner. You can use a pipeline resolver to run a GraphQL query against multiple data sources.</p> </li> </ul>',
    )
    maxBatchSize: Optional[conint(ge=0, le=2000)] = Field(
        None, description='The maximum batching size for a resolver.'
    )
    pipelineConfig: Optional[PipelineConfig] = Field(
        None,
        description='The pipeline configuration for a resolver of kind <code>PIPELINE</code>.',
    )
    requestMappingTemplate: Optional[
        constr(pattern=r'^.*$', min_length=1, max_length=65536)
    ] = Field(
        None,
        description='<p>The new request mapping template.</p> <p>A resolver uses a request mapping template to convert a GraphQL expression into a format that a data source can understand. Mapping templates are written in Apache Velocity Template Language (VTL).</p> <p>VTL request mapping templates are optional when using an Lambda data source. For all other data sources, VTL request and response mapping templates are required.</p>',
    )
    responseMappingTemplate: Optional[
        constr(pattern=r'^.*$', min_length=1, max_length=65536)
    ] = Field(None, description='The new response mapping template.')
    runtime: Optional[Runtime] = Field(
        None,
        description='Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.',
    )
    syncConfig: Optional[SyncConfig] = Field(
        None,
        description='<p>Describes a Sync configuration for a resolver.</p> <p>Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.</p>',
    )


class AdditionalAuthenticationProvider(BaseModel):
    authenticationType: Optional[AuthenticationType] = None
    lambdaAuthorizerConfig: Optional[LambdaAuthorizerConfig] = None
    openIDConnectConfig: Optional[OpenIDConnectConfig] = None
    userPoolConfig: Optional[CognitoUserPoolConfig] = None


class AdditionalAuthenticationProviders(
    RootModel[List[AdditionalAuthenticationProvider]]
):
    root: List[AdditionalAuthenticationProvider]


class AuthorizationConfig(BaseModel):
    authorizationType: AuthorizationType
    awsIamConfig: Optional[AwsIamConfig] = None


class CachingConfig(BaseModel):
    cachingKeys: Optional[CachingKeys] = None
    ttl: Long


class CodeError(BaseModel):
    errorType: Optional[String] = None
    location: Optional[CodeErrorLocation] = None
    value: Optional[String] = None


class CodeErrors(RootModel[List[CodeError]]):
    root: List[CodeError]


class CreateDomainNameResponse(BaseModel):
    domainNameConfig: Optional[DomainNameConfig] = None


class CreateFunctionRequest(BaseModel):
    code: Optional[Code] = None
    dataSourceName: ResourceName
    description: Optional[String] = None
    functionVersion: Optional[String] = None
    maxBatchSize: Optional[MaxBatchSize] = None
    name: ResourceName
    requestMappingTemplate: Optional[MappingTemplate] = None
    responseMappingTemplate: Optional[MappingTemplate] = None
    runtime: Optional[AppSyncRuntime] = None
    syncConfig: Optional[SyncConfig] = None


class CreateGraphqlApiRequest(BaseModel):
    additionalAuthenticationProviders: Optional[AdditionalAuthenticationProviders] = (
        None
    )
    authenticationType: AuthenticationType
    lambdaAuthorizerConfig: Optional[LambdaAuthorizerConfig] = None
    logConfig: Optional[LogConfig] = None
    name: String
    openIDConnectConfig: Optional[OpenIDConnectConfig] = None
    tags: Optional[TagMap] = None
    userPoolConfig: Optional[UserPoolConfig] = None
    xrayEnabled: Optional[Boolean] = None


class CreateResolverRequest(BaseModel):
    cachingConfig: Optional[CachingConfig] = None
    code: Optional[Code] = None
    dataSourceName: Optional[ResourceName] = None
    fieldName: ResourceName
    kind: Optional[ResolverKind] = None
    maxBatchSize: Optional[MaxBatchSize] = None
    pipelineConfig: Optional[PipelineConfig] = None
    requestMappingTemplate: Optional[MappingTemplate] = None
    responseMappingTemplate: Optional[MappingTemplate] = None
    runtime: Optional[AppSyncRuntime] = None
    syncConfig: Optional[SyncConfig] = None


class CreateTypeResponse(BaseModel):
    type: Optional[Type] = None


class EvaluateCodeErrorDetail(BaseModel):
    codeErrors: Optional[CodeErrors] = None
    message: Optional[ErrorMessage] = None


class EvaluateCodeResponse(BaseModel):
    error: Optional[EvaluateCodeErrorDetail] = None
    evaluationResult: Optional[EvaluationResult] = None
    logs: Optional[Logs] = None


class EvaluateMappingTemplateResponse(BaseModel):
    error: Optional[ErrorDetail] = None
    evaluationResult: Optional[EvaluationResult] = None
    logs: Optional[Logs] = None


class FunctionConfiguration(BaseModel):
    code: Optional[Code] = None
    dataSourceName: Optional[ResourceName] = None
    description: Optional[String] = None
    functionArn: Optional[String] = None
    functionId: Optional[String] = None
    functionVersion: Optional[String] = None
    maxBatchSize: Optional[MaxBatchSize] = None
    name: Optional[ResourceName] = None
    requestMappingTemplate: Optional[MappingTemplate] = None
    responseMappingTemplate: Optional[MappingTemplate] = None
    runtime: Optional[AppSyncRuntime] = None
    syncConfig: Optional[SyncConfig] = None


class Functions(RootModel[List[FunctionConfiguration]]):
    root: List[FunctionConfiguration]


class GetFunctionResponse(BaseModel):
    functionConfiguration: Optional[FunctionConfiguration] = None


class GetTypeResponse(BaseModel):
    type: Optional[Type] = None


class GraphqlApi(BaseModel):
    additionalAuthenticationProviders: Optional[AdditionalAuthenticationProviders] = (
        None
    )
    apiId: Optional[String] = None
    arn: Optional[String] = None
    authenticationType: Optional[AuthenticationType] = None
    lambdaAuthorizerConfig: Optional[LambdaAuthorizerConfig] = None
    logConfig: Optional[LogConfig] = None
    name: Optional[ResourceName] = None
    openIDConnectConfig: Optional[OpenIDConnectConfig] = None
    tags: Optional[TagMap] = None
    uris: Optional[MapOfStringToString] = None
    userPoolConfig: Optional[UserPoolConfig] = None
    wafWebAclArn: Optional[String] = None
    xrayEnabled: Optional[Boolean] = None


class GraphqlApis(RootModel[List[GraphqlApi]]):
    root: List[GraphqlApi]


class HttpDataSourceConfig(BaseModel):
    authorizationConfig: Optional[AuthorizationConfig] = None
    endpoint: Optional[String] = None


class ListFunctionsResponse(BaseModel):
    functions: Optional[Functions] = None
    nextToken: Optional[PaginationToken] = None


class ListGraphqlApisResponse(BaseModel):
    graphqlApis: Optional[GraphqlApis] = None
    nextToken: Optional[PaginationToken] = None


class ListTagsForResourceResponse(BaseModel):
    tags: Optional[TagMap] = None


class ListTypesResponse(BaseModel):
    nextToken: Optional[PaginationToken] = None
    types: Optional[TypeList] = None


class Resolver(BaseModel):
    cachingConfig: Optional[CachingConfig] = None
    code: Optional[Code] = None
    dataSourceName: Optional[ResourceName] = None
    fieldName: Optional[ResourceName] = None
    kind: Optional[ResolverKind] = None
    maxBatchSize: Optional[MaxBatchSize] = None
    pipelineConfig: Optional[PipelineConfig] = None
    requestMappingTemplate: Optional[MappingTemplate] = None
    resolverArn: Optional[String] = None
    responseMappingTemplate: Optional[MappingTemplate] = None
    runtime: Optional[AppSyncRuntime] = None
    syncConfig: Optional[SyncConfig] = None
    typeName: Optional[ResourceName] = None


class Resolvers(RootModel[List[Resolver]]):
    root: List[Resolver]


class UpdateDataSourceRequest(BaseModel):
    description: Optional[String] = None
    dynamodbConfig: Optional[DynamodbDataSourceConfig] = None
    elasticsearchConfig: Optional[ElasticsearchDataSourceConfig] = None
    eventBridgeConfig: Optional[EventBridgeDataSourceConfig] = None
    httpConfig: Optional[HttpDataSourceConfig] = None
    lambdaConfig: Optional[LambdaDataSourceConfig] = None
    openSearchServiceConfig: Optional[OpenSearchServiceDataSourceConfig] = None
    relationalDatabaseConfig: Optional[RelationalDatabaseDataSourceConfig] = None
    serviceRoleArn: Optional[String] = None
    type: DataSourceType


class UpdateFunctionResponse(BaseModel):
    functionConfiguration: Optional[FunctionConfiguration] = None


class UpdateGraphqlApiRequest(BaseModel):
    additionalAuthenticationProviders: Optional[AdditionalAuthenticationProviders] = (
        None
    )
    authenticationType: Optional[AuthenticationType] = None
    lambdaAuthorizerConfig: Optional[LambdaAuthorizerConfig] = None
    logConfig: Optional[LogConfig] = None
    name: String
    openIDConnectConfig: Optional[OpenIDConnectConfig] = None
    userPoolConfig: Optional[UserPoolConfig] = None
    xrayEnabled: Optional[Boolean] = None


class UpdateGraphqlApiResponse(BaseModel):
    graphqlApi: Optional[GraphqlApi] = None


class UpdateResolverRequest(BaseModel):
    cachingConfig: Optional[CachingConfig] = None
    code: Optional[Code] = None
    dataSourceName: Optional[ResourceName] = None
    kind: Optional[ResolverKind] = None
    maxBatchSize: Optional[MaxBatchSize] = None
    pipelineConfig: Optional[PipelineConfig] = None
    requestMappingTemplate: Optional[MappingTemplate] = None
    responseMappingTemplate: Optional[MappingTemplate] = None
    runtime: Optional[AppSyncRuntime] = None
    syncConfig: Optional[SyncConfig] = None


class UpdateResolverResponse(BaseModel):
    resolver: Optional[Resolver] = None


class V1ApisPostRequest(BaseModel):
    additionalAuthenticationProviders: Optional[
        List[AdditionalAuthenticationProvider]
    ] = Field(
        None,
        description='A list of additional authentication providers for the <code>GraphqlApi</code> API.',
    )
    authenticationType: AuthenticationType = Field(
        ...,
        description='The authentication type: API key, Identity and Access Management (IAM), OpenID Connect (OIDC), Amazon Cognito user pools, or Lambda.',
    )
    lambdaAuthorizerConfig: Optional[LambdaAuthorizerConfig1] = Field(
        None,
        description='A <code>LambdaAuthorizerConfig</code> specifies how to authorize AppSync API access when using the <code>AWS_LAMBDA</code> authorizer mode. Be aware that an AppSync API can have only one Lambda authorizer configured at a time.',
    )
    logConfig: Optional[LogConfig1] = Field(
        None, description='The Amazon CloudWatch Logs configuration.'
    )
    name: str = Field(
        ..., description='A user-supplied name for the <code>GraphqlApi</code>.'
    )
    openIDConnectConfig: Optional[OpenIDConnectConfig1] = Field(
        None, description='Describes an OpenID Connect (OIDC) configuration.'
    )
    tags: Optional[Dict[str, TagValue]] = Field(
        None,
        description='A map with keys of <code>TagKey</code> objects and values of <code>TagValue</code> objects.',
    )
    userPoolConfig: Optional[UserPoolConfig1] = Field(
        None, description='Describes an Amazon Cognito user pool configuration.'
    )
    xrayEnabled: Optional[bool] = Field(
        None,
        description='A flag indicating whether to use X-Ray tracing for the <code>GraphqlApi</code>.',
    )


class V1ApisApiIdPostRequest(BaseModel):
    additionalAuthenticationProviders: Optional[
        List[AdditionalAuthenticationProvider]
    ] = Field(
        None,
        description='A list of additional authentication providers for the <code>GraphqlApi</code> API.',
    )
    authenticationType: Optional[AuthenticationType] = Field(
        None,
        description='The new authentication type for the <code>GraphqlApi</code> object.',
    )
    lambdaAuthorizerConfig: Optional[LambdaAuthorizerConfig1] = Field(
        None,
        description='A <code>LambdaAuthorizerConfig</code> specifies how to authorize AppSync API access when using the <code>AWS_LAMBDA</code> authorizer mode. Be aware that an AppSync API can have only one Lambda authorizer configured at a time.',
    )
    logConfig: Optional[LogConfig1] = Field(
        None, description='The Amazon CloudWatch Logs configuration.'
    )
    name: str = Field(
        ..., description='The new name for the <code>GraphqlApi</code> object.'
    )
    openIDConnectConfig: Optional[OpenIDConnectConfig1] = Field(
        None, description='Describes an OpenID Connect (OIDC) configuration.'
    )
    userPoolConfig: Optional[UserPoolConfig1] = Field(
        None, description='Describes an Amazon Cognito user pool configuration.'
    )
    xrayEnabled: Optional[bool] = Field(
        None,
        description='A flag indicating whether to use X-Ray tracing for the <code>GraphqlApi</code>.',
    )


class HttpConfig(BaseModel):
    authorizationConfig: Optional[AuthorizationConfig] = None
    endpoint: Optional[String] = None


class V1ApisApiIdDatasourcesPostRequest(BaseModel):
    description: Optional[str] = Field(
        None, description='A description of the <code>DataSource</code>.'
    )
    dynamodbConfig: Optional[DynamodbConfig] = Field(
        None, description='Describes an Amazon DynamoDB data source configuration.'
    )
    elasticsearchConfig: Optional[ElasticsearchConfig] = Field(
        None,
        description='<p>Describes an OpenSearch data source configuration.</p> <p>As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch Service. This configuration is deprecated. For new data sources, use <a>OpenSearchServiceDataSourceConfig</a> to specify an OpenSearch data source.</p>',
    )
    eventBridgeConfig: Optional[EventBridgeConfig] = Field(
        None,
        description='Describes an Amazon EventBridge bus data source configuration.',
    )
    httpConfig: Optional[HttpConfig] = Field(
        None, description='Describes an HTTP data source configuration.'
    )
    lambdaConfig: Optional[LambdaConfig] = Field(
        None, description='Describes an Lambda data source configuration.'
    )
    name: constr(pattern=r'[_A-Za-z][_0-9A-Za-z]*', min_length=1, max_length=65536) = (
        Field(..., description='A user-supplied name for the <code>DataSource</code>.')
    )
    openSearchServiceConfig: Optional[OpenSearchServiceConfig] = Field(
        None, description='Describes an OpenSearch data source configuration.'
    )
    relationalDatabaseConfig: Optional[RelationalDatabaseConfig] = Field(
        None, description='Describes a relational database data source configuration.'
    )
    serviceRoleArn: Optional[str] = Field(
        None,
        description='The Identity and Access Management (IAM) service role Amazon Resource Name (ARN) for the data source. The system assumes this role when accessing the data source.',
    )
    type: Type3 = Field(..., description='The type of the <code>DataSource</code>.')


class V1ApisApiIdDatasourcesNamePostRequest(BaseModel):
    description: Optional[str] = Field(
        None, description='The new description for the data source.'
    )
    dynamodbConfig: Optional[DynamodbConfig] = Field(
        None, description='Describes an Amazon DynamoDB data source configuration.'
    )
    elasticsearchConfig: Optional[ElasticsearchConfig] = Field(
        None,
        description='<p>Describes an OpenSearch data source configuration.</p> <p>As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch Service. This configuration is deprecated. For new data sources, use <a>OpenSearchServiceDataSourceConfig</a> to specify an OpenSearch data source.</p>',
    )
    eventBridgeConfig: Optional[EventBridgeConfig] = Field(
        None,
        description='Describes an Amazon EventBridge bus data source configuration.',
    )
    httpConfig: Optional[HttpConfig] = Field(
        None, description='Describes an HTTP data source configuration.'
    )
    lambdaConfig: Optional[LambdaConfig] = Field(
        None, description='Describes an Lambda data source configuration.'
    )
    openSearchServiceConfig: Optional[OpenSearchServiceConfig] = Field(
        None, description='Describes an OpenSearch data source configuration.'
    )
    relationalDatabaseConfig: Optional[RelationalDatabaseConfig] = Field(
        None, description='Describes a relational database data source configuration.'
    )
    serviceRoleArn: Optional[str] = Field(
        None,
        description='The new service role Amazon Resource Name (ARN) for the data source.',
    )
    type: Type3 = Field(..., description='The new data source type.')


class CreateDataSourceRequest(BaseModel):
    description: Optional[String] = None
    dynamodbConfig: Optional[DynamodbDataSourceConfig] = None
    elasticsearchConfig: Optional[ElasticsearchDataSourceConfig] = None
    eventBridgeConfig: Optional[EventBridgeDataSourceConfig] = None
    httpConfig: Optional[HttpDataSourceConfig] = None
    lambdaConfig: Optional[LambdaDataSourceConfig] = None
    name: ResourceName
    openSearchServiceConfig: Optional[OpenSearchServiceDataSourceConfig] = None
    relationalDatabaseConfig: Optional[RelationalDatabaseDataSourceConfig] = None
    serviceRoleArn: Optional[String] = None
    type: DataSourceType


class CreateFunctionResponse(BaseModel):
    functionConfiguration: Optional[FunctionConfiguration] = None


class CreateGraphqlApiResponse(BaseModel):
    graphqlApi: Optional[GraphqlApi] = None


class CreateResolverResponse(BaseModel):
    resolver: Optional[Resolver] = None


class DataSource(BaseModel):
    dataSourceArn: Optional[String] = None
    description: Optional[String] = None
    dynamodbConfig: Optional[DynamodbDataSourceConfig] = None
    elasticsearchConfig: Optional[ElasticsearchDataSourceConfig] = None
    eventBridgeConfig: Optional[EventBridgeDataSourceConfig] = None
    httpConfig: Optional[HttpDataSourceConfig] = None
    lambdaConfig: Optional[LambdaDataSourceConfig] = None
    name: Optional[ResourceName] = None
    openSearchServiceConfig: Optional[OpenSearchServiceDataSourceConfig] = None
    relationalDatabaseConfig: Optional[RelationalDatabaseDataSourceConfig] = None
    serviceRoleArn: Optional[String] = None
    type: Optional[DataSourceType] = None


class DataSources(RootModel[List[DataSource]]):
    root: List[DataSource]


class GetDataSourceResponse(BaseModel):
    dataSource: Optional[DataSource] = None


class GetGraphqlApiResponse(BaseModel):
    graphqlApi: Optional[GraphqlApi] = None


class GetResolverResponse(BaseModel):
    resolver: Optional[Resolver] = None


class ListDataSourcesResponse(BaseModel):
    dataSources: Optional[DataSources] = None
    nextToken: Optional[PaginationToken] = None


class ListResolversByFunctionResponse(BaseModel):
    nextToken: Optional[PaginationToken] = None
    resolvers: Optional[Resolvers] = None


class ListResolversResponse(BaseModel):
    nextToken: Optional[PaginationToken] = None
    resolvers: Optional[Resolvers] = None


class UpdateDataSourceResponse(BaseModel):
    dataSource: Optional[DataSource] = None


class CreateDataSourceResponse(BaseModel):
    dataSource: Optional[DataSource] = None
